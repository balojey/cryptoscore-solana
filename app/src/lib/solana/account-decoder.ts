/**
 * AccountDecoder - Deserializes account data from on-chain state
 *
 * Provides methods for decoding all program account types using Borsh deserialization.
 * Each account type has a discriminator byte at position 0 for type identification.
 *
 * @module account-decoder
 *
 * @example
 * ```typescript
 * const accountInfo = await connection.getAccountInfo(marketPDA)
 * if (accountInfo) {
 *   const market = AccountDecoder.decodeMarket(accountInfo.data)
 *   console.log('Market:', market)
 * }
 * ```
 */

import { PublicKey } from '@solana/web3.js'
import { deserialize } from 'borsh'

/**
 * Anchor account discriminators (first 8 bytes of account data)
 * These are automatically generated by Anchor based on the account name
 * Format: first 8 bytes of SHA256("account:<AccountName>")
 *
 * @constant DISCRIMINATORS
 */
const DISCRIMINATORS = {
  // These are placeholders - Anchor generates these automatically
  // We'll skip discriminator validation for now
  FACTORY: 0,
  MARKET: 1,
  PARTICIPANT: 2,
  USER_STATS: 3,
}

// Borsh schemas for account data (without discriminator - we skip it manually)
const FactorySchema = {
  struct: {
    authority: { array: { type: 'u8', len: 32 } },
    marketCount: 'u64',
    totalVolume: 'u64',
  },
}

const MarketSchema = {
  struct: {
    factory: { array: { type: 'u8', len: 32 } },
    creator: { array: { type: 'u8', len: 32 } },
    matchId: 'string',
    entryFee: 'u64',
    kickoffTime: 'i64',
    endTime: 'i64',
    status: 'u8',
    outcome: { option: 'u8' },
    totalPool: 'u64',
    participantCount: 'u32',
    homeCount: 'u32',
    drawCount: 'u32',
    awayCount: 'u32',
    isPublic: 'bool',
    bump: 'u8',
  },
}

const ParticipantSchema = {
  struct: {
    market: { array: { type: 'u8', len: 32 } },
    user: { array: { type: 'u8', len: 32 } },
    prediction: 'u8',
    joinedAt: 'i64',
    hasWithdrawn: 'bool',
    bump: 'u8',
  },
}

const UserStatsSchema = {
  struct: {
    user: { array: { type: 'u8', len: 32 } },
    totalMarkets: 'u64',
    totalWins: 'u64',
    totalEarnings: 'u64',
    currentStreak: 'u64',
  },
}

/**
 * Factory account data structure
 *
 * @interface Factory
 * @property {PublicKey} authority - Factory authority
 * @property {bigint} marketCount - Total number of markets created
 * @property {bigint} totalVolume - Total volume across all markets in lamports
 */
export interface Factory {
  authority: PublicKey
  marketCount: bigint
  totalVolume: bigint
}

/**
 * Market account data structure
 *
 * @interface Market
 * @property {PublicKey} factory - Factory PDA that created this market
 * @property {PublicKey} creator - Market creator's public key
 * @property {string} matchId - Unique match identifier
 * @property {bigint} entryFee - Entry fee in lamports
 * @property {bigint} kickoffTime - Match kickoff time (Unix timestamp)
 * @property {bigint} endTime - Market end time (Unix timestamp)
 * @property {boolean} isPublic - Whether market is public or private
 * @property {number} status - Market status (0 = Open, 1 = Live, 2 = Resolved)
 * @property {number} outcome - Match outcome (0 = HOME, 1 = DRAW, 2 = AWAY, 255 = None)
 * @property {bigint} totalPool - Total pool size in lamports
 * @property {bigint} participantCount - Total number of participants
 * @property {bigint} homeCount - Number of HOME predictions
 * @property {bigint} drawCount - Number of DRAW predictions
 * @property {bigint} awayCount - Number of AWAY predictions
 */
export interface Market {
  factory: PublicKey
  creator: PublicKey
  matchId: string
  entryFee: bigint
  kickoffTime: bigint
  endTime: bigint
  isPublic: boolean
  status: number
  outcome: number
  totalPool: bigint
  participantCount: bigint
  homeCount: bigint
  drawCount: bigint
  awayCount: bigint
}

/**
 * Participant account data structure
 *
 * @interface Participant
 * @property {PublicKey} market - Market PDA
 * @property {PublicKey} user - Participant's public key
 * @property {number} prediction - User's prediction (0 = HOME, 1 = DRAW, 2 = AWAY)
 * @property {bigint} joinedAt - Timestamp when user joined (Unix timestamp)
 * @property {boolean} hasWithdrawn - Whether user has withdrawn rewards
 * @property {number} bump - PDA bump seed
 */
export interface Participant {
  market: PublicKey
  user: PublicKey
  prediction: number
  joinedAt: bigint
  hasWithdrawn: boolean
  bump: number
}

/**
 * UserStats account data structure
 *
 * @interface UserStats
 * @property {PublicKey} user - User's public key
 * @property {bigint} totalMarkets - Total markets participated in
 * @property {bigint} totalWins - Total wins
 * @property {bigint} totalEarnings - Total earnings in lamports
 * @property {bigint} currentStreak - Current winning streak
 */
export interface UserStats {
  user: PublicKey
  totalMarkets: bigint
  totalWins: bigint
  totalEarnings: bigint
  currentStreak: bigint
}

/**
 * AccountDecoder class for deserializing account data
 *
 * @class AccountDecoder
 *
 * @example
 * ```typescript
 * const accountInfo = await connection.getAccountInfo(marketPDA)
 * if (accountInfo && AccountDecoder.verifyDiscriminator(accountInfo.data, 'MARKET')) {
 *   const market = AccountDecoder.decodeMarket(accountInfo.data)
 * }
 * ```
 */
export class AccountDecoder {
  /**
   * Decode Factory account data
   *
   * @param {Buffer} data - Raw account data from Solana
   * @returns {Factory} Decoded factory account
   * @throws {Error} If deserialization fails
   *
   * @example
   * ```typescript
   * const factory = AccountDecoder.decodeFactory(accountInfo.data)
   * console.log('Market count:', factory.marketCount)
   * ```
   */
  static decodeFactory(data: Buffer): Factory {
    // Skip 8-byte Anchor discriminator
    const accountData = data.slice(8)
    const decoded = deserialize(FactorySchema, accountData) as any
    return {
      authority: new PublicKey(decoded.authority),
      marketCount: BigInt(decoded.marketCount),
      totalVolume: BigInt(decoded.totalVolume),
    }
  }

  /**
   * Decode Market account data
   *
   * @param {Buffer} data - Raw account data from Solana
   * @returns {Market} Decoded market account
   * @throws {Error} If deserialization fails
   *
   * @example
   * ```typescript
   * const market = AccountDecoder.decodeMarket(accountInfo.data)
   * console.log('Match ID:', market.matchId)
   * console.log('Entry fee:', market.entryFee)
   * console.log('Status:', market.status)
   * ```
   */
  static decodeMarket(data: Buffer): Market {
    // Skip 8-byte Anchor discriminator
    const accountData = data.slice(8)
    const decoded = deserialize(MarketSchema, accountData) as any

    // Handle Option<MatchOutcome> - if None, outcome will be null
    const outcome = decoded.outcome !== null && decoded.outcome !== undefined ? decoded.outcome : 255

    return {
      factory: new PublicKey(decoded.factory),
      creator: new PublicKey(decoded.creator),
      matchId: decoded.matchId,
      entryFee: BigInt(decoded.entryFee),
      kickoffTime: BigInt(decoded.kickoffTime),
      endTime: BigInt(decoded.endTime),
      isPublic: decoded.isPublic,
      status: decoded.status,
      outcome,
      totalPool: BigInt(decoded.totalPool),
      participantCount: BigInt(decoded.participantCount),
      homeCount: BigInt(decoded.homeCount),
      drawCount: BigInt(decoded.drawCount),
      awayCount: BigInt(decoded.awayCount),
    }
  }

  /**
   * Decode Participant account data
   *
   * @param {Buffer} data - Raw account data from Solana
   * @returns {Participant} Decoded participant account
   * @throws {Error} If deserialization fails
   *
   * @example
   * ```typescript
   * const participant = AccountDecoder.decodeParticipant(accountInfo.data)
   * console.log('Prediction:', participant.prediction)
   * console.log('Has withdrawn:', participant.hasWithdrawn)
   * ```
   */
  static decodeParticipant(data: Buffer): Participant {
    // Skip 8-byte Anchor discriminator
    const accountData = data.slice(8)
    const decoded = deserialize(ParticipantSchema, accountData) as any
    return {
      market: new PublicKey(decoded.market),
      user: new PublicKey(decoded.user),
      prediction: decoded.prediction,
      joinedAt: BigInt(decoded.joinedAt),
      hasWithdrawn: decoded.hasWithdrawn,
      bump: decoded.bump,
    }
  }

  /**
   * Decode UserStats account data
   *
   * @param {Buffer} data - Raw account data from Solana
   * @returns {UserStats} Decoded user stats account
   * @throws {Error} If deserialization fails
   *
   * @example
   * ```typescript
   * const stats = AccountDecoder.decodeUserStats(accountInfo.data)
   * console.log('Total wins:', stats.totalWins)
   * console.log('Win streak:', stats.currentStreak)
   * ```
   */
  static decodeUserStats(data: Buffer): UserStats {
    // Skip 8-byte Anchor discriminator
    const accountData = data.slice(8)
    const decoded = deserialize(UserStatsSchema, accountData) as any
    return {
      user: new PublicKey(decoded.user),
      totalMarkets: BigInt(decoded.totalMarkets),
      totalWins: BigInt(decoded.totalWins),
      totalEarnings: BigInt(decoded.totalEarnings),
      currentStreak: BigInt(decoded.currentStreak),
    }
  }

  /**
   * Verify account discriminator matches expected type
   *
   * @param {Buffer} data - Raw account data
   * @param {keyof typeof DISCRIMINATORS} expectedType - Expected account type
   * @returns {boolean} True if discriminator matches
   *
   * @example
   * ```typescript
   * if (AccountDecoder.verifyDiscriminator(data, 'MARKET')) {
   *   const market = AccountDecoder.decodeMarket(data)
   * } else {
   *   console.error('Wrong account type')
   * }
   * ```
   */
  static verifyDiscriminator(data: Buffer, expectedType: keyof typeof DISCRIMINATORS): boolean {
    if (data.length === 0)
      return false
    const discriminator = data[0]
    return discriminator === DISCRIMINATORS[expectedType]
  }
}
